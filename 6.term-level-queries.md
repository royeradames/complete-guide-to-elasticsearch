- [Searching for a term](#searching-for-a-term)
- [searching for multiple terms](#searching-for-multiple-terms)
- [Retrieving documents based on IDs](#retrieving-documents-based-on-ids)
- [Matching documents with range values](#matching-documents-with-range-values)
- [Working with relative dates (date math)](#working-with-relative-dates-date-math)
  - [Rounding time](#rounding-time)
- [Matching documents with non-null values (finding docs with field that exist)](#matching-documents-with-non-null-values-finding-docs-with-field-that-exist)
  - [Query for matching documents that have at least one tag](#query-for-matching-documents-that-have-at-least-one-tag)
  - [how does the query even work?](#how-does-the-query-even-work)
- [Matching based on prefixes](#matching-based-on-prefixes)

# Searching for a term

Query for exact matching. So use it for searching no fields, dates or keyword fields.

```JSON
GET products/_search
{
  "query": {
    "term": {
      "is_active": true
    }
  }
}

# you need to do an object if you want to add options
GET products/_search
{
  "query": {
    "term": {
      "is_active": {
        "value": true
      }
    }
  }
}
```

# searching for multiple terms

Similar to in clause in SQL

```JSON
GET products/_search
{
  "query": {
    "terms": {
      "tags.keyword": [
        "Soup",
        "Cake"
      ]
    }
  }
}
```

# Retrieving documents based on IDs

```JSON
GET products/_search
{
  "query": {
    "ids": {
      "values": [1,2,3]
    }
  }
}
```

# Matching documents with range values

- `gte` - Greater-than or equal to.
- `lte` - Less-than or equal to.
- `gt` - Greater-than.
- `lt` - Less-than.

```JSON
# gte = greator than
# lte = less than
GET products/_search
{
  "query": {
    "range": {
      "created": {
        "gte": 1,
        "lte": 5
      }
    }
  }
}

# define the input date format
# elastic search will handle the new format for matching documents
GET products/_search
{
  "query": {
    "range": {
      "created": {
        "gte": "01-01-2010",
        "lte": "31-12-2010",
        "format": "dd-MM-yyyy"
      }
    }
  }
}
```

Important for handling range of date in a calendar.

# Working with relative dates (date math)

`<anchor date>||<date math>`

[Date math reference](https://www.elastic.co/guide/en/elasticsearch/reference/current/common-options.html#date-math)

```JSON
# 2010 minus 1 year
GET products/_search
{
  "query": {
    "range": {
      "created": {
        "gte": "2012/01/01||-1y"
      }
    }
  }
}

# minutes 1 year and 1 day
GET products/_search
{
  "query": {
    "range": {
      "created": {
        "gte": "2012/01/01||-1y-1d"
      }
    }
  }
}

# round by Month after taking a year off
# m = minutes
GET products/_search
{
  "query": {
    "range": {
      "created": {
        "gte": "2010/01/01||-1y/M"
      }
    }
  }
}

# round Month then take a year off
GET products/_search
{
  "query": {
    "range": {
      "created": {
        "gte": "2010/01/01||/M-1y"
      }
    }
  }
}

# use the current time has the anchor
# you don't need(or would work) the(with) pipes.
GET products/_search
{
  "query": {
    "range": {
      "created": {
        "gte": "now/M-1y"
      }
    }
  }
}

# now(current date stamp) works without date math
GET products/_search
{
  "query": {
    "range": {
      "created": {
        "gte": "now"
      }
    }
  }
}
```

## Rounding time

| Operator | Rounding direction | Before     | After      |
| -------- | ------------------ | ---------- | ---------- |
| gt       | up                 | 2020-01-20 | 2010-01-31 |
| gte      | down               | 2010-01-20 | 2010-01-01 |
| it       | down               | 2010-01-20 | 2010-01-01 |
| ite      | up                 | 2010-01-20 | 2010-01-01 |

# Matching documents with non-null values (finding docs with field that exist)

non-null value =  any value that is not null

If you're familiar with programming languages such as BHP, for example, then you will know that an empty string is equal to null unless you do a strict check. This is not the case in ElasticSearch, meaning that a **field containing an empty string would be matched with an existing query**.

So what about an **empty array**, for instance, that would not match an existing query clause because an array with no values does not satisfy the definition of the existing query, which is that the fields should have at least one non null value since we have to textfield being an array of strings we can use to exist.

## Query for matching documents that have at least one tag

```JSON
# Matching documents with non-null values #
GET products/_search
{
  "query": {
    "exists": {
      "field": "tags"
    }
  }
}
```

## how does the query even work?

Well, you might remember the underscore field underscore names mezza fields from one of the previous sections.

ElasticSearch uses this method internally when finding documents that contain a non null value for a given field.

You might also remember the null underscore value mapping parameter, which also has an effect on the exists query.

If you specify a null value, a document will be matched by the query because it no longer has an empty value with that onto the next term level query.

# Matching based on prefixes

Matches the start of a field

```JSON
GET products/_search
{
  "query": {
    "prefix": {
      "tags.keyword": "Vege"
    }
  }
}
```

